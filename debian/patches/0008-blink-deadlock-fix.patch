From: Jason Rhinelander <jason@imaginary.ca>
Date: Sat, 18 Jan 2020 12:12:29 -0400
Subject: blink deadlock fix

Remove pre-HF14 p2p vote relaying command

Remove pre-HF14 code

Fix rare blink pool deadlock
---
 src/cryptonote_core/blockchain.cpp                 | 46 ++++++-------------
 src/cryptonote_core/cryptonote_core.cpp            | 22 +++------
 src/cryptonote_core/tx_pool.cpp                    | 28 +++++-------
 src/cryptonote_core/tx_pool.h                      | 29 ++++++++----
 src/cryptonote_protocol/cryptonote_protocol_defs.h | 40 -----------------
 .../cryptonote_protocol_handler.h                  |  3 --
 .../cryptonote_protocol_handler.inl                | 52 ----------------------
 .../cryptonote_protocol_handler_common.h           |  5 ---
 src/cryptonote_protocol/quorumnet.cpp              |  5 ++-
 src/rpc/core_rpc_server.cpp                        |  9 ++--
 10 files changed, 58 insertions(+), 181 deletions(-)

diff --git a/src/cryptonote_core/blockchain.cpp b/src/cryptonote_core/blockchain.cpp
index d4d0fa9..8ce5d70 100644
--- a/src/cryptonote_core/blockchain.cpp
+++ b/src/cryptonote_core/blockchain.cpp
@@ -1990,14 +1990,7 @@ bool Blockchain::handle_get_blocks(NOTIFY_REQUEST_GET_BLOCKS::request& arg, NOTI
   LOG_PRINT_L3("Blockchain::" << __func__);
   std::unique_lock<decltype(m_blockchain_lock)> blockchain_lock{m_blockchain_lock, std::defer_lock};
   auto blink_lock = m_tx_pool.blink_shared_lock(std::defer_lock);
-  bool blink_enabled = false;
-  if (get_current_hard_fork_version() >= HF_VERSION_BLINK)
-  {
-    blink_enabled = true;
-    std::lock(blockchain_lock, blink_lock);
-  }
-  else
-    blockchain_lock.lock();
+  std::lock(blockchain_lock, blink_lock);
 
   db_rtxn_guard rtxn_guard (m_db);
   rsp.current_blockchain_height = get_current_blockchain_height();
@@ -2043,16 +2036,13 @@ bool Blockchain::handle_get_blocks(NOTIFY_REQUEST_GET_BLOCKS::request& arg, NOTI
     std::vector<crypto::hash> missed_tx_ids;
     get_transactions_blobs(block.tx_hashes, block_entry.txs, missed_tx_ids);
 
-    if (blink_enabled)
+    for (auto &h : block.tx_hashes)
     {
-      for (auto &h : block.tx_hashes)
+      if (auto blink = m_tx_pool.get_blink(h))
       {
-        if (auto blink = m_tx_pool.get_blink(h))
-        {
-          auto l = blink->shared_lock();
-          block_entry.blinks.emplace_back();
-          blink->fill_serialization_data(block_entry.blinks.back());
-        }
+        auto l = blink->shared_lock();
+        block_entry.blinks.emplace_back();
+        blink->fill_serialization_data(block_entry.blinks.back());
       }
     }
 
@@ -2077,16 +2067,9 @@ bool Blockchain::handle_get_blocks(NOTIFY_REQUEST_GET_BLOCKS::request& arg, NOTI
 bool Blockchain::handle_get_txs(NOTIFY_REQUEST_GET_TXS::request& arg, NOTIFY_NEW_TRANSACTIONS::request& rsp)
 {
   LOG_PRINT_L3("Blockchain::" << __func__);
-  std::unique_lock<decltype(m_blockchain_lock)> blockchain_lock{m_blockchain_lock, std::defer_lock};
+  auto blockchain_lock = tools::unique_lock(m_blockchain_lock, std::defer_lock);
   auto blink_lock = m_tx_pool.blink_shared_lock(std::defer_lock);
-  bool blink_enabled = false;
-  if (get_current_hard_fork_version() >= HF_VERSION_BLINK)
-  {
-    blink_enabled = true;
-    std::lock(blockchain_lock, blink_lock);
-  }
-  else
-    blockchain_lock.lock();
+  std::lock(blockchain_lock, blink_lock);
 
   db_rtxn_guard rtxn_guard (m_db);
   std::vector<crypto::hash> missed;
@@ -2097,16 +2080,13 @@ bool Blockchain::handle_get_txs(NOTIFY_REQUEST_GET_TXS::request& arg, NOTIFY_NEW
   // Look for any missed txes in the mempool:
   m_tx_pool.find_transactions(missed, rsp.txs);
 
-  if (blink_enabled)
+  for (auto &h : arg.txs)
   {
-    for (auto &h : arg.txs)
+    if (auto blink = m_tx_pool.get_blink(h))
     {
-      if (auto blink = m_tx_pool.get_blink(h))
-      {
-        rsp.blinks.emplace_back();
-        auto l = blink->shared_lock();
-        blink->fill_serialization_data(rsp.blinks.back());
-      }
+      rsp.blinks.emplace_back();
+      auto l = blink->shared_lock();
+      blink->fill_serialization_data(rsp.blinks.back());
     }
   }
 
diff --git a/src/cryptonote_core/cryptonote_core.cpp b/src/cryptonote_core/cryptonote_core.cpp
index 66d88d8..dbc13f5 100644
--- a/src/cryptonote_core/cryptonote_core.cpp
+++ b/src/cryptonote_core/cryptonote_core.cpp
@@ -1305,7 +1305,7 @@ namespace cryptonote
       auto mempool_lock = m_mempool.blink_shared_lock();
       for (size_t i = 0; i < blinks.size(); i++)
       {
-        if (want[i] && m_mempool.has_blink(blinks[i].tx_hash, true /*have lock*/))
+        if (want[i] && m_mempool.has_blink(blinks[i].tx_hash))
         {
           MDEBUG("Ignoring blink data for " << blinks[i].tx_hash << ": already have blink signatures");
           want[i] = false; // Already have it, move along
@@ -1402,7 +1402,7 @@ namespace cryptonote
 
     for (auto &b : blinks)
       if (b->approved())
-        if (m_mempool.add_existing_blink(b, true /*have lock*/))
+        if (m_mempool.add_existing_blink(b))
           added++;
 
     MINFO("Added blink signatures for " << added << " blinks");
@@ -1687,20 +1687,10 @@ namespace cryptonote
 
     if (!p2p_votes.empty())
     {
-      if (hf_version >= cryptonote::network_version_14_blink_lns)
-      {
-        NOTIFY_NEW_SERVICE_NODE_VOTE::request req{};
-        req.votes = std::move(p2p_votes);
-        cryptonote_connection_context fake_context{};
-        get_protocol()->relay_service_node_votes(req, fake_context);
-      }
-      else
-      {
-        NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request req{};
-        req.votes = std::move(p2p_votes);
-        cryptonote_connection_context fake_context{};
-        get_protocol()->relay_service_node_votes(req, fake_context);
-      }
+      NOTIFY_NEW_SERVICE_NODE_VOTE::request req{};
+      req.votes = std::move(p2p_votes);
+      cryptonote_connection_context fake_context{};
+      get_protocol()->relay_service_node_votes(req, fake_context);
     }
 
     return true;
diff --git a/src/cryptonote_core/tx_pool.cpp b/src/cryptonote_core/tx_pool.cpp
index 54981e8..a6cd2ad 100644
--- a/src/cryptonote_core/tx_pool.cpp
+++ b/src/cryptonote_core/tx_pool.cpp
@@ -508,11 +508,9 @@ namespace cryptonote
     return result;
   }
   //---------------------------------------------------------------------------------
-  bool tx_memory_pool::add_existing_blink(std::shared_ptr<blink_tx> blink_ptr, bool have_lock)
+  bool tx_memory_pool::add_existing_blink(std::shared_ptr<blink_tx> blink_ptr)
   {
     assert(blink_ptr && blink_ptr->approved());
-    auto lock = have_lock ? blink_unique_lock(std::defer_lock) : blink_unique_lock();
-
     auto &ptr = m_blinks[blink_ptr->get_txhash()];
     if (ptr)
       return false;
@@ -521,18 +519,16 @@ namespace cryptonote
     return true;
   }
   //---------------------------------------------------------------------------------
-  std::shared_ptr<blink_tx> tx_memory_pool::get_blink(const crypto::hash &tx_hash, bool have_lock) const
+  std::shared_ptr<blink_tx> tx_memory_pool::get_blink(const crypto::hash &tx_hash) const
   {
-    auto lock = have_lock ? blink_shared_lock(std::defer_lock) : blink_shared_lock();
     auto it = m_blinks.find(tx_hash);
     if (it != m_blinks.end())
         return it->second;
     return {};
   }
   //---------------------------------------------------------------------------------
-  bool tx_memory_pool::has_blink(const crypto::hash &tx_hash, bool have_lock) const
+  bool tx_memory_pool::has_blink(const crypto::hash &tx_hash) const
   {
-    auto lock = have_lock ? blink_shared_lock(std::defer_lock) : blink_shared_lock();
     return m_blinks.find(tx_hash) != m_blinks.end();
   }
 
@@ -616,8 +612,8 @@ namespace cryptonote
   //---------------------------------------------------------------------------------
   std::vector<crypto::hash> tx_memory_pool::get_mined_blinks(const std::set<uint64_t> &want_heights) const
   {
-
     std::vector<crypto::hash> result;
+
     auto hnh = get_blink_hashes_and_mined_heights();
     auto &hashes = hnh.first;
     auto &heights = hnh.second;
@@ -778,7 +774,7 @@ namespace cryptonote
         // don't prune the kept_by_block ones, they're likely added because we're adding a block with those
         // don't prune blink txes
         // don't prune the one we just added
-        if (meta.kept_by_block || this->has_blink(txid, true /*have lock*/) || txid == skip)
+        if (meta.kept_by_block || this->has_blink(txid) || txid == skip)
           return true;
 
         if (this->remove_tx(txid, &meta, &del_it))
@@ -1237,17 +1233,15 @@ namespace cryptonote
   //TODO: investigate whether boolean return is appropriate
   bool tx_memory_pool::get_transactions_and_spent_keys_info(std::vector<tx_info>& tx_infos, std::vector<spent_key_image_info>& key_image_infos, bool include_sensitive_data) const
   {
-    auto locks = tools::unique_locks(m_transactions_lock, m_blockchain);
+    auto tx_lock = tools::unique_lock(m_transactions_lock, std::defer_lock);
+    auto bc_lock = tools::unique_lock(m_blockchain, std::defer_lock);
+    auto blink_lock = blink_shared_lock(std::defer_lock);
+    boost::lock(tx_lock, bc_lock, blink_lock);
 
     tx_infos.reserve(m_blockchain.get_txpool_tx_count());
     key_image_infos.reserve(m_blockchain.get_txpool_tx_count());
 
-    bool blink_enabled = m_blockchain.get_current_hard_fork_version() >= HF_VERSION_BLINK;
-    auto blink_lock = blink_shared_lock(std::defer_lock);
-    if (blink_enabled)
-      blink_lock.lock();
-
-    m_blockchain.for_all_txpool_txes([&tx_infos, this, blink_enabled, include_sensitive_data](const crypto::hash &txid, const txpool_tx_meta_t &meta, const cryptonote::blobdata *bd){
+    m_blockchain.for_all_txpool_txes([&tx_infos, this, include_sensitive_data](const crypto::hash &txid, const txpool_tx_meta_t &meta, const cryptonote::blobdata *bd){
       transaction tx;
       if (!parse_and_validate_tx_from_blob(*bd, tx))
       {
@@ -1276,7 +1270,7 @@ namespace cryptonote
       txi.last_relayed_time = include_sensitive_data ? meta.last_relayed_time : 0;
       txi.do_not_relay = meta.do_not_relay;
       txi.double_spend_seen = meta.double_spend_seen;
-      txi.blink = blink_enabled && has_blink(txid, true /*have lock*/);
+      txi.blink = has_blink(txid);
       return true;
     }, true, include_sensitive_data);
 
diff --git a/src/cryptonote_core/tx_pool.h b/src/cryptonote_core/tx_pool.h
index 2889d60..277659d 100644
--- a/src/cryptonote_core/tx_pool.h
+++ b/src/cryptonote_core/tx_pool.h
@@ -157,6 +157,8 @@ namespace cryptonote
     /**
      * @brief attempts to add a blink transaction to the transaction pool.
      *
+     * This method must be called without a held blink lock.
+     *
      * This is only for use for new transactions that should not exist yet on the chain or mempool
      * (and will fail if already does).  See `add_existing_blink` instead to add blink data about a
      * transaction that already exists.  This is only meant to be called during the SN blink signing
@@ -184,6 +186,8 @@ namespace cryptonote
     /**
      * @brief attempts to add blink transaction information about an existing blink transaction
      *
+     * You *must* already hold a blink_unique_lock().
+     *
      * This method takes an approved blink_tx and records it in the known blinks data.  No check is
      * done that the transaction actually exists on the blockchain or mempool.  It is assumed that
      * the given shared_ptr is a new blink that is not yet shared between threads (and thus doesn't
@@ -193,33 +197,34 @@ namespace cryptonote
      * *not* check it (except as an assert when compiling in debug mode).
      *
      * @param blink the blink_tx shared_ptr
-     * @param have_lock can be specified as true to avoid taking out a unique lock on the blinks
-     * data structure; it should only be specified if a unique lock on the blink data is already
-     * held externally, i.e. by obtaining a lock with `blink_unique_lock`.
      *
      * @return true if the blink data was recorded, false if the given blink was already known.
      */
-    bool add_existing_blink(std::shared_ptr<blink_tx> blink, bool have_lock = false);
+    bool add_existing_blink(std::shared_ptr<blink_tx> blink);
 
     /**
      * @brief accesses blink tx details if the given tx hash is a known, approved blink tx, nullptr
      * otherwise.
      *
+     * You *must* already hold a blink_shared_lock() or blink_unique_lock().
+     *
      * @param tx_hash the hash of the tx to access
-     * @param have_lock can be specified as true to avoid taking out a shared lock; it should only
-     * be specified if a shared lock on the blink data is already held externally.
      */
-    std::shared_ptr<blink_tx> get_blink(const crypto::hash &tx_hash, bool have_lock = false) const;
+    std::shared_ptr<blink_tx> get_blink(const crypto::hash &tx_hash) const;
 
     /**
      * Equivalent to `(bool) get_blink(...)`, but slightly more efficient when the blink information
      * isn't actually needed beyond an existance test (as it avoids copying the shared_ptr).
+     *
+     * You *must* already hold a blink_shared_lock() or blink_unique_lock().
      */
-    bool has_blink(const crypto::hash &tx_hash, bool have_lock = false) const;
+    bool has_blink(const crypto::hash &tx_hash) const;
 
     /**
      * @brief modifies a vector of tx hashes to remove any that have known valid blink signatures
      *
+     * Must not currently hold a blink lock.
+     *
      * @param txs the tx hashes to check
      */
     void keep_missing_blinks(std::vector<crypto::hash> &tx_hashes) const;
@@ -227,6 +232,8 @@ namespace cryptonote
     /**
      * @brief returns checksums of blink txes included in recently mined blocks and in the mempool
      *
+     * Must not currently hold a blink lock.
+     *
      * The returned map consists of height => hashsum pairs where the height is the height in which
      * the blink transactions were mined and the hashsum is a checksum of all the blink txes mined
      * at that height.  Unmined mempool blink txes are included at a height of 0.  Only heights
@@ -239,6 +246,8 @@ namespace cryptonote
      * @brief returns the hashes of any non-immutable blink transactions mined in the given heights.
      * A height of 0 is allowed: it indicates blinks in the mempool.
      *
+     * Must not currently hold a blink lock.
+     *
      * Note that this returned hashes by MINED HEIGHTS, not BLINK HEIGHTS where are a different
      * concept.
      *
@@ -694,6 +703,8 @@ namespace cryptonote
      * rollback is needed for the blink tx.  (That is, all blocks with height >=
      * blink_rollback_height need to be popped).
      *
+     * This method is *not* called with a blink lock held.
+     *
      * @return true if the conflicting transactions have been removed (and/or the rollback height
      * set), false if tx removal and/or rollback are insufficient to eliminate conflicting txes.
      */
@@ -759,7 +770,7 @@ namespace cryptonote
 
     // Helper method: retrieves hashes and mined heights of blink txes since the immutable block;
     // mempool blinks are included with a height of 0.  Also takes care of cleaning up any blinks
-    // that have become immutable.
+    // that have become immutable.  Blink lock must not be already held.
     std::pair<std::vector<crypto::hash>, std::vector<uint64_t>> get_blink_hashes_and_mined_heights() const;
   };
 }
diff --git a/src/cryptonote_protocol/cryptonote_protocol_defs.h b/src/cryptonote_protocol/cryptonote_protocol_defs.h
index 149fc06..5f58912 100644
--- a/src/cryptonote_protocol/cryptonote_protocol_defs.h
+++ b/src/cryptonote_protocol/cryptonote_protocol_defs.h
@@ -347,46 +347,6 @@ namespace cryptonote
     };
   };
 
-  /************************************************************************/
-  /*                                                                      */
-  /************************************************************************/
-  // TODO(loki) - remove this after HF14
-  struct NOTIFY_NEW_SERVICE_NODE_VOTE_OLD
-  {
-  private:
-    struct alignas(8) blob { unsigned char data[120]; };
-  public:
-    const static int ID = BC_COMMANDS_POOL_BASE + 12;
-    struct request
-    {
-      std::vector<service_nodes::quorum_vote_t> votes;
-
-      BEGIN_KV_SERIALIZE_MAP()
-        auto &votes = this_ref.votes;
-
-        std::vector<blob> vote_blobs;
-        if (is_store) // means: "serializing".  Hate epee 2x: this is both badly named, and gross template parameter misuse.
-        {
-          vote_blobs.resize(votes.size());
-          for (size_t i = 0; i < votes.size(); i++)
-            vote_to_blob(votes[i], vote_blobs[i].data);
-        }
-        // Hate epee some more: this time for deficient serialization macros:
-        //KV_SERIALIZE_CONTAINER_POD_AS_BLOB_N(vote_blobs, "votes");
-        epee::serialization::selector<is_store>::serialize_stl_container_pod_val_as_blob(vote_blobs, stg, hparent_section, "votes");
-        if (!is_store)
-        {
-          // Hate epee even more:
-          auto &v = const_cast<std::vector<service_nodes::quorum_vote_t>&>(votes);
-          v.resize(vote_blobs.size());
-          for (size_t i = 0; i < v.size(); i++)
-            blob_to_vote(vote_blobs[i].data, v[i]);
-        }
-      END_KV_SERIALIZE_MAP()
-    };
-  };
-
-
   /************************************************************************/
   /*                                                                      */
   /************************************************************************/
diff --git a/src/cryptonote_protocol/cryptonote_protocol_handler.h b/src/cryptonote_protocol/cryptonote_protocol_handler.h
index 4d79415..29f8f66 100644
--- a/src/cryptonote_protocol/cryptonote_protocol_handler.h
+++ b/src/cryptonote_protocol/cryptonote_protocol_handler.h
@@ -81,7 +81,6 @@ namespace cryptonote
       HANDLE_NOTIFY_T2(NOTIFY_REQUEST_FLUFFY_MISSING_TX, &cryptonote_protocol_handler::handle_request_fluffy_missing_tx)
       HANDLE_NOTIFY_T2(NOTIFY_UPTIME_PROOF, &cryptonote_protocol_handler::handle_uptime_proof)
       HANDLE_NOTIFY_T2(NOTIFY_NEW_SERVICE_NODE_VOTE, &cryptonote_protocol_handler::handle_notify_new_service_node_vote)
-      HANDLE_NOTIFY_T2(NOTIFY_NEW_SERVICE_NODE_VOTE_OLD, &cryptonote_protocol_handler::handle_notify_new_service_node_vote_old)
       HANDLE_NOTIFY_T2(NOTIFY_REQUEST_BLOCK_BLINKS, &cryptonote_protocol_handler::handle_request_block_blinks)
       HANDLE_NOTIFY_T2(NOTIFY_RESPONSE_BLOCK_BLINKS, &cryptonote_protocol_handler::handle_response_block_blinks)
     END_INVOKE_MAP2()
@@ -120,7 +119,6 @@ namespace cryptonote
     int handle_request_fluffy_missing_tx(int command, NOTIFY_REQUEST_FLUFFY_MISSING_TX::request& arg, cryptonote_connection_context& context);
     int handle_uptime_proof(int command, NOTIFY_UPTIME_PROOF::request& arg, cryptonote_connection_context& context);
     int handle_notify_new_service_node_vote(int command, NOTIFY_NEW_SERVICE_NODE_VOTE::request& arg, cryptonote_connection_context& context);
-    int handle_notify_new_service_node_vote_old(int command, NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& context);
     int handle_request_block_blinks(int command, NOTIFY_REQUEST_BLOCK_BLINKS::request& arg, cryptonote_connection_context& context);
     int handle_response_block_blinks(int command, NOTIFY_RESPONSE_BLOCK_BLINKS::request& arg, cryptonote_connection_context& context);
 
@@ -155,7 +153,6 @@ namespace cryptonote
     virtual bool relay_transactions(NOTIFY_NEW_TRANSACTIONS::request& arg, cryptonote_connection_context& exclude_context);
     virtual bool relay_uptime_proof(NOTIFY_UPTIME_PROOF::request& arg, cryptonote_connection_context& exclude_context);
     virtual bool relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE::request& arg, cryptonote_connection_context& exclude_context);
-    virtual bool relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& exclude_context);
     //----------------------------------------------------------------------------------
     //bool get_payload_sync_data(HANDSHAKE_DATA::request& hshd, cryptonote_connection_context& context);
     bool should_drop_connection(cryptonote_connection_context& context, uint32_t next_stripe);
diff --git a/src/cryptonote_protocol/cryptonote_protocol_handler.inl b/src/cryptonote_protocol/cryptonote_protocol_handler.inl
index 42fe561..6585a67 100644
--- a/src/cryptonote_protocol/cryptonote_protocol_handler.inl
+++ b/src/cryptonote_protocol/cryptonote_protocol_handler.inl
@@ -922,50 +922,6 @@ namespace cryptonote
     return 1;
   }
 
-  //------------------------------------------------------------------------------------------------------------------------  
-  // TODO: delete this after HF14
-  template<class t_core>
-  int t_cryptonote_protocol_handler<t_core>::handle_notify_new_service_node_vote_old(int command, NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& context)
-  {
-    MLOG_P2P_MESSAGE("Received NOTIFY_NEW_SERVICE_NODE_VOTE_OLD (" << arg.votes.size() << " txes)");
-
-    if(context.m_state != cryptonote_connection_context::state_normal)
-      return 1;
-
-    if(!is_synchronized())
-    {
-      LOG_DEBUG_CC(context, "Received new service node vote while syncing, ignored");
-      return 1;
-    }
-
-    for(auto it = arg.votes.begin(); it != arg.votes.end();)
-    {
-      cryptonote::vote_verification_context vvc = {};
-      m_core.add_service_node_vote(*it, vvc);
-
-      if (vvc.m_verification_failed)
-      {
-        LOG_PRINT_CCONTEXT_L1("Vote type: " << it->type << ", verification failed, dropping connection");
-        drop_connection(context, false /*add_fail*/, false /*flush_all_spans i.e. delete cached block data from this peer*/);
-        return 1;
-      }
-
-      if (vvc.m_added_to_pool)
-      {
-        it++;
-      }
-      else
-      {
-        it = arg.votes.erase(it);
-      }
-    }
-
-    if (arg.votes.size())
-      relay_service_node_votes(arg, context);
-
-    return 1;
-  }
-
   //------------------------------------------------------------------------------------------------------------------------  
   template<class t_core>
   int t_cryptonote_protocol_handler<t_core>::handle_request_fluffy_missing_tx(int command, NOTIFY_REQUEST_FLUFFY_MISSING_TX::request& arg, cryptonote_connection_context& context)
@@ -2508,14 +2464,6 @@ skip:
       m_core.set_service_node_votes_relayed(arg.votes);
     return result;
   }
-  template<class t_core>
-  bool t_cryptonote_protocol_handler<t_core>::relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& exclude_context)
-  {
-    bool result = relay_to_synchronized_peers<NOTIFY_NEW_SERVICE_NODE_VOTE_OLD>(arg, exclude_context);
-    if (result)
-      m_core.set_service_node_votes_relayed(arg.votes);
-    return result;
-  }
   //------------------------------------------------------------------------------------------------------------------------
   template<class t_core>
   bool t_cryptonote_protocol_handler<t_core>::relay_transactions(NOTIFY_NEW_TRANSACTIONS::request& arg, cryptonote_connection_context& exclude_context)
diff --git a/src/cryptonote_protocol/cryptonote_protocol_handler_common.h b/src/cryptonote_protocol/cryptonote_protocol_handler_common.h
index 356b240..fef060e 100644
--- a/src/cryptonote_protocol/cryptonote_protocol_handler_common.h
+++ b/src/cryptonote_protocol/cryptonote_protocol_handler_common.h
@@ -45,7 +45,6 @@ namespace cryptonote
     virtual bool relay_uptime_proof(NOTIFY_UPTIME_PROOF::request& arg, cryptonote_connection_context& exclude_context)=0;
     //virtual bool request_objects(NOTIFY_REQUEST_GET_OBJECTS::request& arg, cryptonote_connection_context& context)=0;
     virtual bool relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE::request& arg, cryptonote_connection_context& exclude_context)=0;
-    virtual bool relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& exclude_context)=0;
   };
 
   /************************************************************************/
@@ -65,10 +64,6 @@ namespace cryptonote
     {
       return false;
     }
-    virtual bool relay_service_node_votes(NOTIFY_NEW_SERVICE_NODE_VOTE_OLD::request& arg, cryptonote_connection_context& exclude_context)
-    {
-      return false;
-    }
     virtual bool relay_uptime_proof(NOTIFY_UPTIME_PROOF::request& arg, cryptonote_connection_context& exclude_context)
     {
       return false;
diff --git a/src/cryptonote_protocol/quorumnet.cpp b/src/cryptonote_protocol/quorumnet.cpp
index 13286bf..a643967 100644
--- a/src/cryptonote_protocol/quorumnet.cpp
+++ b/src/cryptonote_protocol/quorumnet.cpp
@@ -741,7 +741,10 @@ void process_blink_signatures(SNNWrapper &snw, const std::shared_ptr<blink_tx> &
     if (became_approved) {
         MINFO("Accumulated enough signatures for blink tx: enabling tx relay");
         auto &pool = snw.core.get_pool();
-        pool.add_existing_blink(btxptr);
+        {
+            auto lock = pool.blink_unique_lock();
+            pool.add_existing_blink(btxptr);
+        }
         pool.set_relayable({{btx.get_txhash()}});
         snw.core.relay_txpool_transactions();
     }
diff --git a/src/rpc/core_rpc_server.cpp b/src/rpc/core_rpc_server.cpp
index da6dd1c..0dc169b 100644
--- a/src/rpc/core_rpc_server.cpp
+++ b/src/rpc/core_rpc_server.cpp
@@ -622,9 +622,8 @@ namespace cryptonote
       LOG_PRINT_L2("Found " << found_in_pool << "/" << vh.size() << " transactions in the pool");
     }
 
-    bool blink_enabled = m_core.get_blockchain_storage().get_current_hard_fork_version() >= HF_VERSION_BLINK;
     uint64_t immutable_height = m_core.get_blockchain_storage().get_immutable_height();
-    auto pool_lock = pool.blink_shared_lock(std::defer_lock); // Defer until/unless we actually need it
+    auto blink_lock = pool.blink_shared_lock(std::defer_lock); // Defer until/unless we actually need it
 
     std::vector<std::string>::const_iterator txhi = req.txs_hashes.begin();
     std::vector<crypto::hash>::const_iterator vhi = vh.begin();
@@ -698,7 +697,7 @@ namespace cryptonote
       }
       auto ptx_it = per_tx_pool_tx_info.find(tx_hash);
       e.in_pool = ptx_it != per_tx_pool_tx_info.end();
-      bool might_be_blink = blink_enabled;
+      bool might_be_blink = true;
       if (e.in_pool)
       {
         e.block_height = e.block_timestamp = std::numeric_limits<uint64_t>::max();
@@ -717,8 +716,8 @@ namespace cryptonote
 
       if (might_be_blink)
       {
-        if (!pool_lock) pool_lock.lock();
-        e.blink = pool.has_blink(tx_hash, true /*have lock*/);
+        if (!blink_lock) blink_lock.lock();
+        e.blink = pool.has_blink(tx_hash);
       }
 
       // fill up old style responses too, in case an old wallet asks
